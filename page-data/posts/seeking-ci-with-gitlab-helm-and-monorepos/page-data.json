{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/seeking-ci-with-gitlab-helm-and-monorepos","result":{"data":{"markdownRemark":{"id":"2b9d8ad9-6d6c-5e9e-834d-ddba7abcb2e4","html":"<p><figure class=\"figure\"><img src=\"https://cdn-images-1.medium.com/max/1000/1*RVEIaW2aJy900CLBKWRW5g.png\" title=\"Its this simple… right?\"><figcaption class=\"figcaption\">Its this simple… right?</figcaption></figure></p>\n<h3 id=\"background\" style=\"position:relative;\"><a href=\"#background\" aria-label=\"background permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Background</h3>\n<p>True continuous integration and deployment are harder than they seem. At least I think so. Its easy to drift or take shortcuts or not really do what you say you are doing. Like everything else in software, it gets harder as you scale. Does every team need a “DevOps person”? Who coordinates new features between teams? O yeah we have microservices right? No need for coordination… </p>\n<p>Somewhere around the 30 engineer mark we knew we needed to make a change. Not all teams had the necessary skill sets, some were better at API management than others. Some applications were more stable. Some were taking short cuts. Here’s how we matured our continuous integration approach while scaling to 100+ engineers working on 40+ microservices using GitLab CI, Docker, Kubernetes, and Helm. </p>\n<p>We landed on <a href=\"https://trunkbaseddevelopment.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">trunk based development</a> and the creation of a monorepo. The choice to use a monorepo wasn’t made lightly. We decided the benefits were just too great to pass on, even for a small to medium sized group. Statically typed interfaces, atomic commits, uniform large-scale refactors, lockstep dependency upgrades, and shared build tooling have all paid dividends. Similar to the microservice philosophy, a monorepo does come at a complexity and engineering cost.</p>\n<p>Some design features of our monorepo:</p>\n<ul>\n<li><strong>It contains everything</strong> — Everything needed to deploy every service we maintain. This means source code and Helm charts.</li>\n<li><strong>Single versions</strong> — Dependency versions are constrained at the root level via Yarn and Gradle. All projects use the same versions of external dependencies. Internal dependencies always use local references.</li>\n<li><strong>Convention over configuration</strong> — We have very specific conventions enabling everything to <em>just work</em>. Add a Dockerfile to your project and the CI job will “automagically” appear.</li>\n<li><strong>Simple workflows</strong> — Multi-step incantations must be kept to a minimum. At any given time, a developer can check out <code class=\"language-text\">trunk</code> and run <code class=\"language-text\">helm install</code>, deploying images built from the exact code they have checked out. Additional overrides can be used to deploy subsets of the system when desired. We work hard to keep deploying as simple as possible.</li>\n</ul>\n<p><figure class=\"figure\"><img src=\"https://cdn-images-1.medium.com/max/1000/0*CrM8_hRPlr_Ew_ka\" title=\"Trunk-Based development | source: https://trunkbaseddevelopment.com/\"><figcaption class=\"figcaption\">Trunk-Based development | source: https://trunkbaseddevelopment.com/</figcaption></figure></p>\n<hr>\n<h3 id=\"building-a-change\" style=\"position:relative;\"><a href=\"#building-a-change\" aria-label=\"building a change permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Building a change</h3>\n<p>When a developer is ready to commit changes, they open a merge request for their feature branch. Opening a merge request on a feature branch creates a <a href=\"https://docs.gitlab.com/ee/ci/merge_request_pipelines/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">pipeline for merge requests</a>.</p>\n<p>Given we are using a monorepo, rebuilding all source images for any given change would be extremely expensive and time consuming. Luckily, GitLab supports detecting which files changed and therefore which Docker images need to be built. Below is an example of a GitLab CI file that will run a common <code class=\"language-text\">docker-build</code> for <code class=\"language-text\">foo</code> service.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token comment\"># Common abstract docker build all builds will extend</span>\n<span class=\"token key atrule\">.docker-build</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">script</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> ./build.sh $SERVICE\n\n<span class=\"token comment\"># Foo service's docker build</span>\n<span class=\"token key atrule\">foo docker build</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">extends</span><span class=\"token punctuation\">:</span> .docker<span class=\"token punctuation\">-</span>build\n  <span class=\"token key atrule\">only</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">changes</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token string\">\"js/foo/**\"</span>\n  <span class=\"token key atrule\">variables</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">SERVICE</span><span class=\"token punctuation\">:</span> foo</code></pre></div>\n<p>All Docker builds extend a common <code class=\"language-text\">.docker-build</code>. In our case, this template calls <code class=\"language-text\">build.sh</code>. Having a wrapper for things like this is great for codifying conventions or configuration checks. The script will…</p>\n<ol>\n<li>Read <code class=\"language-text\">$SERVICE</code> to understand which directory to find the relevant <code class=\"language-text\">Dockerfile</code> it will build.</li>\n<li>Determine which <em>type</em> of Docker build we are doing. Are we local on a feature branch? Are we in our CI environment on a feature branch, or just merged into trunk? More on this later…</li>\n<li>Enforce static checks such as linting, unit tests, and image scanning when appropriate.</li>\n</ol>\n<h3 id=\"the-nitty-gritty\" style=\"position:relative;\"><a href=\"#the-nitty-gritty\" aria-label=\"the nitty gritty permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The nitty gritty</h3>\n<p>Initially, we created our CI definitions by hand. We found this was error prone and a maintenance nightmare (duh).</p>\n<p><figure class=\"figure\"><img src=\"https://cdn-images-1.medium.com/max/1000/1*65QX_UnhRcvg-Nzsa6q2LQ.jpeg\" title=\"No one likes maintaining YAML\"><figcaption class=\"figcaption\">No one likes maintaining YAML</figcaption></figure></p>\n<p>To automate this, we wrote a script that will:</p>\n<ol>\n<li>Find all <code class=\"language-text\">Dockerfile</code> in the monorepo.</li>\n<li>Find the collocated build file — package.json, build.gradle, etc</li>\n<li>Parses the build file for local maven or npm dependency references — <code class=\"language-text\">file:../commonLibrary</code> or <code class=\"language-text\">project(&quot;:commonLibary&quot;)</code>.</li>\n<li>Output a <code class=\"language-text\">.gitlab-ci.yml</code> containing all docker builds.</li>\n</ol>\n<p>These were relatively simply to implement. #3 is worth diving into a little bit. We have local libraries that contain common code many services might share. Think client libraries, mixins, statically typed service interfaces, etc. One of the benefits of a monorepo is the ability to reference local dependencies. If a developer is going to introduce a breaking change to their API, they are responsible for updating the client code or working with the appropriate engineers. Netflix has a <a href=\"https://netflixtechblog.com/towards-true-continuous-integration-distributed-repositories-and-dependencies-2a2e3108c051\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">great post</a> on the topic worth checking out.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">-js\n|-fooApp\n|  |-package.json\n|  |-Dockerfile\n|-barApp\n|  |-package.json\n|  |-Dockerfile\n|-commonLibary\n|  |-package.json</code></pre></div>\n<p>An example directory structure with Dockerfiles and a common library</p>\n<p>With all of that automation in place something changes. What I’m describing is something closer to a <a href=\"https://en.wikipedia.org/wiki/Declarative_programming\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">declarative model</a> for creating CI builds. Rather than every developer updating the CI definition to add their service, they simply add a Dockerfile and run a script (could also be automated). The script handles creating new CI jobs, dynamically resolving local dependencies, and deriving the correct rules and configuration for building. Declarative seems to be a natural progression in the DevOps world.</p>\n<blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">GitOps: versioned CI/CD on top of declarative infrastructure. Stop scripting and start shipping. <a href=\"https://t.co/SgUlHgNrnY\">https://t.co/SgUlHgNrnY</a></p>&mdash; Kelsey Hightower (@kelseyhightower) <a href=\"https://twitter.com/kelseyhightower/status/953638870888849408?ref_src=twsrc%5Etfw\">January 17, 2018</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n<h3 id=\"testing-the-change\" style=\"position:relative;\"><a href=\"#testing-the-change\" aria-label=\"testing the change permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Testing the change</h3>\n<p>Now that we have <code class=\"language-text\">feature-branch</code> built, we need to deploy and test it. Our pipeline will need to:</p>\n<ol>\n<li>Allocate a cluster</li>\n<li>Deploy</li>\n<li>Test</li>\n</ol>\n<p>I won’t focus too much on allocating the Kubernetes cluster. We keep a pool of test environments but a better approach might be dynamically creating and destroying as need. Maybe we’ll get there one day. One thing to keep in mind is speed. No one wants to wait 3+ hours to get their changes into <code class=\"language-text\">trunk</code>. We try to keep regression testing to &#x3C; 30 minutes. In practice, there is a balance between the <a href=\"https://cloud.google.com/blog/products/devops-sre/using-the-four-keys-to-measure-your-devops-performance\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">four DevOps KPIs</a>. How much change failure rate or test maintenance is worth sacrificing for MTTR or time to ship?</p>\n<p>Once the pipeline has allocated an environment, it will use Helm to deploy all charts within the monorepo. To do this, our CI pipeline must know which services have new docker images to deploy. Remember <code class=\"language-text\">build.sh</code>? This script produces an artifact whenever it builds a docker image. The CI deploy job will look for all artifacts and create a set of Helm overrides.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># Install the monorepo charts and wait for all services to be ready</span>\n<span class=\"token comment\"># Override just foo to deploy the new image</span>\nhelm <span class=\"token function\">install</span> --wait --timeout monorepo charts/monorepo --set foo.image.tag<span class=\"token operator\">=</span>my-feature-branch</code></pre></div>\n<p>Example Helm install command for foo image in my-feature-branch</p>\n<p>Once deployed, the pipeline can run a suite of automated tests. Just like our services, automated tests are built as a Docker image. This allows us to treat them just like any other service. The only difference is test containers run to completion, so we define the them as a <a href=\"https://kubernetes.io/docs/concepts/workloads/controllers/job/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Kubernetes Job</a>.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">helm <span class=\"token function\">install</span> tests charts/tests\n<span class=\"token comment\"># The job pod should have backoffLimit set to 0 to only run once.</span>\nkubectl <span class=\"token function\">wait</span> --for<span class=\"token operator\">=</span>condition<span class=\"token operator\">=</span>complete job/test\n<span class=\"token comment\"># Once complete, parse the exit code</span>\n<span class=\"token assign-left variable\">code</span><span class=\"token operator\">=</span><span class=\"token string\">\"<span class=\"token variable\"><span class=\"token variable\">$(</span>kubectl get pod automated-test -o json <span class=\"token operator\">|</span> jq .status.containerStatuses<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>.lastState.terminated.exitCode<span class=\"token variable\">)</span></span>\"</span>\n<span class=\"token comment\"># Pass or fail based on exit code</span>\n<span class=\"token builtin class-name\">exit</span> <span class=\"token variable\">$code</span></code></pre></div>\n<p>At this point we should have a high level of confidence the feature branch is ready to be merged. The next thing to do is merge our new feature into <code class=\"language-text\">trunk</code>. But how does that change become part of the latest deployment?</p>\n<h3 id=\"integrating-the-change\" style=\"position:relative;\"><a href=\"#integrating-the-change\" aria-label=\"integrating the change permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Integrating the change</h3>\n<blockquote>\n<p>For any given checkout of trunk, a developer should be able to run helm install charts/monorepo and have a deployment that matches the code checked out.</p>\n</blockquote>\n<p>Seemed simple enough…we soon realized this presents a real chicken and egg problem.</p>\n<p>When a feature branch is merged, we build a new version of each docker image that was updated. We tag the image with a unique id corresponding to the merge request. This gives nice traceability back to which merge request was responsible for triggering the build.</p>\n<p>The broken egg occurs when we try to get this tag back to our Helm charts. This tag needs to be checked into source control for <code class=\"language-text\">helm install</code> to work the way we want. Initially, developers were required to manually update a Helm chart’s values file to reflect the new version.</p>\n<ol>\n<li>Developer opens merge request.</li>\n<li>Developer takes merge request number and updates <code class=\"language-text\">values.yaml</code>.</li>\n<li>Developer pushes new commit.</li>\n</ol>\n<p>But <a href=\"http://threevirtues.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">good programmers are lazy</a>. I’m not doing that every time I want to merge something. It also creates lots of merge conflicts.</p>\n<h3 id=\"automatic-versioning\" style=\"position:relative;\"><a href=\"#automatic-versioning\" aria-label=\"automatic versioning permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Automatic versioning</h3>\n<p>This the <em>dirtiest</em> part of our CI/CD process. When a merge request passes all gates, our CI pipeline makes a Git commit via a bot. This commit updates a special file within a service’s Helm chart named <code class=\"language-text\">version.yaml</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">monorepo/\n|-- Charts/\n|    | foo/\n|      |-- templates\n|      |-- values.yaml\n|      |-- version.yaml # &lt;---- auto-updated\n|\t | bar/\n|-- js/\n|    |-- packages/\n|        |-- foo/\n|        |-- bar/</code></pre></div>\n<p>Example directory structure for source code and charts</p>\n<p>This file is parsed via a Helm <a href=\"https://helm.sh/docs/chart_template_guide/named_templates/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">named template</a>.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">-</span> define \"image\" <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">-</span> /* Merge version.yaml with .Values. <span class=\"token important\">*/</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span> <span class=\"token punctuation\">-</span> $overrides <span class=\"token punctuation\">:</span>= .Files.Get \"version.yaml\" <span class=\"token punctuation\">|</span> fromYaml <span class=\"token punctuation\">|</span> merge .Values <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span> <span class=\"token punctuation\">-</span> $tag <span class=\"token punctuation\">:</span>= overrides.image.tag'\n<span class=\"token punctuation\">...</span></code></pre></div>\n<p>The beauty of this template is anything in <code class=\"language-text\">version.yaml</code> can still be overridden by <code class=\"language-text\">values.yaml</code> or the <code class=\"language-text\">--set</code> command. The custom file is treated as the lowest priority due to how <code class=\"language-text\">merge</code> works.</p>\n<h3 id=\"dealing-with-conflicts\" style=\"position:relative;\"><a href=\"#dealing-with-conflicts\" aria-label=\"dealing with conflicts permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Dealing with conflicts</h3>\n<p>Constantly churning versioning files means constant merge conflicts. Our first implementation maintained the image tag in the chart’s <code class=\"language-text\">values.yaml</code>. This was a huge mistake. The problem was this file is used for other configuration items. If the file is only ever used for automated versioning, we can make assumptions about conflicts and therefore automate resolving conflicts.</p>\n<p>Conflicts happen when 2 developers update the same service. Two developers, Allie and Bob check out <code class=\"language-text\">trunk</code>. Allie merges updates to <code class=\"language-text\">foo</code> which result in a new version. Bob is also updating <code class=\"language-text\">foo</code> but now has conflicts with Allie’s versioning file. We can be smart about this though. If the versioning file is the only conflict, we can effectively ignore Allie’s update. We can rebase Bob’s changes onto <code class=\"language-text\">trunk</code> and resolve the versioning conflict with:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># From Bob's feature branch</span>\n<span class=\"token function\">git</span> rebase origin/trunk\n<span class=\"token function\">git</span> checkout --theirs charts/<span class=\"token variable\">$service</span>/version.yaml\n<span class=\"token comment\"># during a rebase, you are now trunk. So take Bob's (their) change.</span></code></pre></div>\n<p>If you want to get real fancy and have access to your Git server, you can actually create a <a href=\"https://git-scm.com/docs/gitattributes#_defining_a_custom_merge_driver\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">custom merge driver</a> which does this behind the scene. Sadly I cannot. Automatic versioning updates was the final piece to our continuous integration puzzle. Shoutout to GitLab as they use a similar approach for maintaining CHANGELOG files.</p>\n<h3 id=\"summary\" style=\"position:relative;\"><a href=\"#summary\" aria-label=\"summary permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Summary</h3>\n<p>This is the way our team decided to implement continuous integration. It isn’t perfect but it works. Our DevOps journey took us down the road of:</p>\n<ol>\n<li>Creating monorepo specific tooling for maintaining CI definitions.</li>\n<li>Automatic detection of changes for building, testing, and deploying.</li>\n<li>A mechanism for always deploying the latest software.</li>\n</ol>\n<p>Continuous integration implementations always feel like a Rube Goldberg machine that functions as a means to an end. Bad automation and workflows make developers less efficient and destroys quality of life. We’ve made those mistakes. But we also learned from them. Hopefully these ideas help someone else struggling to achieve DevOps nirvana… or at least teaches them a couple things not to do. Thanks for reading!</p>","fields":{"slug":"/posts/seeking-ci-with-gitlab-helm-and-monorepos","tagSlugs":["/tag/dev-ops/","/tag/gitlab/","/tag/helm/","/tag/kubernetes/"]},"frontmatter":{"date":"2021-02-27","description":"There comes a time when every team must dive deep into the automation ocean. For us it was somewhere around the 30 engineer mark. Here’s how we matured our continuous integration approach while scaling to 100+ engineers working on 40+ microservices using GitLab CI, Docker, Kubernetes, and Helm.","tags":["DevOps","Gitlab","Helm","Kubernetes"],"title":"Seeking continuous integration with GitLab, Helm, and monorepos","socialImage":{"publicURL":"/static/fde6918da34fc0355751bb967f40b823/gitlab.png"},"reddit":"https://www.reddit.com/r/devops/comments/m0f39w/monorepo_cicd_with_gitlab_and_helm","linkedin":"https://www.linkedin.com/posts/alanmasciangelo_seeking-continuous-integration-with-gitlab-activity-6774674251120160768-YihX"}}},"pageContext":{"slug":"/posts/seeking-ci-with-gitlab-helm-and-monorepos"}},"staticQueryHashes":["251939775","401334301","825871152"]}